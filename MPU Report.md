본 보고서는 **TC387 멀티코어 환경**에서 현대오토에버 **모빌진 클래식(Mobilgene Classic) R4.4.0**을 기반으로 진행되는 차량용 제어기 SW 개발 프로젝트의 CPU 부하 이슈를 분석하고, **ASIL-B 및 QM 혼합 등급(Mixed-ASIL)** 요구사항 준수를 위한 **MPU(Memory Protection Unit)** 적용의 필연성과 부하 저감 대책을 상세히 다룹니다.

---

## 1. MPU 적용 및 Scalability Class(SC) 선정의 필연성 분석

### 1.1 ISO 26262와 간섭으로부터의 자유(FFI)
차량용 기능 안전 표준인 ISO 26262에 따르면, 서로 다른 ASIL 등급(ASIL-B와 QM)의 SW 컴포넌트가 동일한 ECU 내에서 공존할 때, **'간섭으로부터의 자유(Freedom from Interference)'**를 보장해야 합니다,. 낮은 등급(QM)의 소프트웨어가 의도치 않게 높은 등급(ASIL-B) 소프트웨어의 메모리 영역을 오염시키는 것을 방지하기 위해 **메모리 파티셔닝(Memory Partitioning)**은 필수적인 기술적 안전 메커니즘입니다,.

### 1.2 AUTOSAR OS Scalability Class 4 (SC4)의 역할
AUTOSAR OS는 기능에 따라 4개의 Scalability Class를 정의합니다.
*   **SC1:** OSEK OS의 기본 기능과 계획된 스케줄 제공.
*   **SC2:** SC1 기능에 **타이밍 보호(Timing Protection)** 기능 추가,.
*   **SC3:** SC1 기능에 하드웨어 MPU를 이용한 **메모리 보호(Memory Protection)** 기능 추가,.
*   **SC4:** **SC2와 SC3의 결합**으로, 메모리 보호와 타이밍 보호를 모두 제공.

본 프로젝트는 **SC4를 적용**하고 있는데, 이는 ASIL-B 기능을 보호하기 위해 QM 소프트웨어의 메모리 오용을 차단(SC3 영역)하고, 특정 소프트웨어가 CPU 자원을 독점하여 실행 시간 예산을 초과하는 것을 감시(SC2 영역)하기 위한 최선의 선택입니다,. TC387과 같은 멀티코어 시스템에서는 OS-Application 사용이 의무화되며, 이는 각 코어 및 파티션 간의 논리적·물리적 경계를 형성하는 기초가 됩니다,.

---

## 2. MPU가 CPU 부하에 영향을 미치는 기술적 원인

MPU 활성화 시 CPU 부하가 10p.p. 이상 상승하는 이유는 하드웨어 및 소프트웨어 계층에서 발생하는 **추가적인 연산 오버헤드** 때문입니다.

### 2.1 컨텍스트 스위칭 시 레지스터 업데이트 오버헤드
TriCore 아키텍처(TC1.6.2P)에서 파티션 간 전환이 발생할 때마다, OS 커널은 **Supervisor 모드**에서 MPU 관련 핵심 시스템 레지스터(CSFR)를 재설정해야 합니다.
*   **레지스터 쓰기 지연:** `MTCR`(Move To Core Register) 명령어를 사용하여 보호 범위(DPR, CPR)를 기록해야 합니다.
*   **파이프라인 플러시(ISYNC):** MPU 설정 변경 후에는 반드시 `ISYNC` 명령어를 실행해야 합니다. 이는 CPU 파이프라인을 완전히 비우고(Flush), 캐시 상태를 무효화하며, 다음 명령어를 다시 인출(Re-fetch)하게 만듭니다. 이 과정에서 수많은 CPU 사이클이 소모되며, 파티션 전환 빈도가 높을수록 부하가 누적됩니다.

### 2.2 파티션 간 통신(IOC) 비용
서로 다른 OS-Application(파티션) 간에 데이터를 전달할 때는 **IOC(Inter-OS-Application Communicator)** 메커니즘을 사용합니다. IOC는 메모리 보호 경계를 넘기 위해 데이터를 별도의 공유 버퍼로 **복사(Copying)**하는 과정을 수반하며, 이는 직접적인 포인터 접근 방식보다 연산량이 훨씬 많습니다,.

---

## 3. 부하 개선을 위한 부문별 체크리스트

### 3.1 애플리케이션 소프트웨어(ASW) 부문
*   **태스크 주기 및 우선순위:** Core 2의 부하가 높으므로, 해당 코어에 할당된 QM 태스크 중 지나치게 짧은 주기(예: 1ms)를 가진 것이 있는지 확인해야 합니다.
*   **런나블 매핑(Runnable Mapping):** 동일한 SW-C 인스턴스에 속한 런나블들이 여러 파티션에 흩어져 불필요한 파티션 전환을 유발하는지 점검합니다.
*   **데이터 통신 빈도:** 파티션 경계를 넘는 S/R 통신이나 C/S 호출이 과도하게 빈번한지 분석합니다.

### 3.2 기초 소프트웨어(BSW) 부문
*   **BSW 파티션 배치:** Core 2에서 실행되는 QM 소프트웨어가 다른 코어에 위치한 BSW 서비스를 빈번하게 호출(Cross-core call)하는지 확인합니다.
*   **인터럽트 처리:** Cat 2 ISR의 실행 시간이 너무 길어 OS 스케줄링 오버헤드를 가중시키고 있지 않은지 점검합니다,.
*   **BswM 모드 전환:** `Immediate` 방식으로 설정된 BswM 액션 리스트가 파티션 전환을 유발하며 실행 시간을 점유하는지 확인합니다.

---

## 4. 부하 저감 대책 및 상세 적용 가이드

### 4.1 파티션 설계 최적화: "최근접 매핑(Nearest Mapping)"
*   **대책:** 상호작용이 빈번한 모듈들을 하나의 파티션(OS-Application)으로 묶어 MPU 재설정 횟수를 줄입니다,.
*   **적용 가이드 (모빌진 R4.4.0):**
    *   `EcucPartition` 설정에서 연관성 높은 SW-C들을 동일한 파티션에 할당합니다.
    *   Core 0의 경우 현재 QM과 ASIL-B가 혼재되어 있으므로, 이들 간의 불필요한 상호작용을 최소화하는 인터페이스 설계가 필요합니다.

### 4.2 BSW 분산 처리: Master/Satellite 구조 활용
*   **대책:** 모든 BSW 처리를 특정 코어(보통 Core 0)의 Master 모듈에 의존하지 않고, 각 코어에 **Satellite 모듈**을 배치하여 로컬에서 처리하게 합니다,,.
*   **적용 가이드:**
    *   통신 스택(COM, CanIf 등)이나 메모리 스택(NvM)을 Master/Satellite 패턴으로 구성합니다,.
    *   Core 2의 QM 소프트웨어가 하드웨어에 접근할 때, 타 코어로 요청을 보내지 않고 Core 2 내의 Satellite BSW를 통해 즉시 처리하도록 `EcucCoreDefinition`과 연결합니다.

### 4.3 IOC 통신 최적화: Push 대신 Pull 방식 적용
*   **대책:** 데이터를 보낼 때마다 알림을 주는 'Push' 방식보다는, 수신 측 태스크가 필요할 때 읽어가는 **'Pull' 방식**을 사용하여 인터럽트와 복사 비용을 줄입니다.
*   **적용 가이드:**
    *   `OsIoc` 설정에서 `OsIocReceiverPullCB` 속성을 활용하여 통신을 최적화합니다.
    *   버퍼의 크기를 적절히 조절하여 오버플로우로 인한 재전송 부하(`IOC_E_LIMIT`)를 방지합니다.

### 4.4 MPU 하드웨어 특성 활용: PRS(Protection Register Sets)
*   **대책:** TC387이 제공하는 **6개의 보호 세트(PRS 0~5)**를 파티션별로 고정 할당하여, 태스크 전환 시 레지스터 전체를 재설정하는 대신 `PSW.PRS` 필드만 변경하여 고속 스위칭을 구현합니다.
*   **적용 가이드:**
    *   빈번하게 실행되는 QM 파티션(Core 2)과 OS 커널용 세트를 PRS에 미리 할당해 둡니다.
    *   모빌진 OS 설정에서 `OsScalabilityClass`가 SC4인 경우, 사용 가능한 PRS 개수를 확인하고 가장 부하가 큰 태스크에 전용 PRS를 바인딩합니다.

### 4.5 신뢰 파티션(Trusted Function)의 제한적 활용
*   **대책:** 성능이 극도로 중요한 하드웨어 제어 루틴은 MPU 제약을 받지 않는 **Trusted OsApplication**에 배치하여 MPU 오버헤드를 우회합니다.
*   **적용 가이드:**
    *   `CallTrustedFunction`을 호출할 때 발생하는 오버헤드와 MPU 보호 해제에 따른 안전 리스크를 분석하여 최소한의 범위에만 적용합니다.
    *   Core 2의 연산 부하 중 단순 데이터 처리 로직은 가급적 비신뢰(Non-trusted) 모드로 유지하되, 드라이버 접근 시에만 신뢰 함수를 호출하도록 설계합니다.

본 가이드를 통해 Core 2의 MPU 전환 오버헤드를 최소화하고 파티션 간의 비효율적인 통신을 개선함으로써, 요구사항인 **CPU Load 80% 이하**를 달성할 수 있을 것으로 사료됩니다. 구체적인 설정값은 모빌진의 `Ecuc` 파라미터 튜닝을 통해 최종 확정하시기 바랍니다.